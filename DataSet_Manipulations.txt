WHAT TO DELETE
-------------------------------------------
MALE_PLAYER:
-player_url
-fifa_update
-update_as_of
-week_foot
-skill_moves
-international_reputation
-work_rate
-body_type
-real_face
-player_tags
-player_traits
- all the last 27 attributes like ls,st,..
Tot deleted : 42 over 108 = 66 attributes to keep
------------------------------------------
Same for FEMALE_PLAYER
------------------------------------------
MALE_COACHES:
-coach_url
-dob
-nation_flag_url
Tot deleted : 3 over 8 = 5 attributes to keep
---------------------------------------------
Same for FEMALE_COACHES
---------------------------------------------
MALE_TEAMS:
-team_url
-fifa_update
-update_as_of
-rival_team
-international_prestige
-domestic_prestige
-starting_xi_avarage_age
-whole_team_avarage_age
-def_style
-def_team_width
-def_team_depth
-off_build_up_play
-off_chance_creation
Tot deleted: 13 over 41 = 28 attributes to keep
-----------------------------------------------
Same for FEMALE_TEAMS





____________________________________________________________________________________
CODE
_____________________________________________________________________________________
db.male_players.aggregate([
  {
    $lookup: {
      from: "male_teams",
      let: { clubId: "$club_team_id", clubName: "$club_name" },
      pipeline: [
        {
          $match: {
            $expr: {
              $and: [
                { $eq: ["$team_id", "$$clubId"] },
                { $eq: ["$team_name", "$$clubName"] }
              ]
            }
          }
        }
      ],
      as: "team_info"
    }
  },
  {
    $unwind: {
      path: "$team_info",
      preserveNullAndEmptyArrays: true
    }
  },
  {
    $group: {
      _id: "$player_id",
      original_id: { $first: "$_id" },
      player_id: { $first: "$player_id" },
      short_name: { $first: "$short_name" },
      long_name: { $first: "$long_name" },
      age: { $first: "$age" },
      dob: { $first: "$dob" },
      height_cm: { $first: "$height_cm" },
      weight_kg: { $first: "$weight_kg" },
      preferred_foot: { $first: "$preferred_foot" },
      nationality_id: { $first: "$nationality_id" },
      nationality_name: { $first: "$nationality_name" },
      gender: { $first: "male" },
      fifaStats: {
        $push: {
          fifa_version: "$fifa_version",
          player_positions: "$player_positions",
          overall: "$overall",
          potential: "$potential",
          value_eur: "$value_eur",
          wage_eur: "$wage_eur",
          club_position: "$club_position",
          club_jersey_number: "$club_jersey_number",
          club_contract_valid_until_year: "$club_contract_valid_until_year",
          league_name: "$league_name",
          league_level: "$league_level",
          nation_team_id: "$nation_team_id",
          nation_position: "$nation_position",
          nation_jersey_number: "$nation_jersey_number",
          release_clause_eur: "$release_clause_eur",
          team: {
            team_mongo_id: "$team_info._id",
            team_id: "$team_info.team_id",
            team_name: "$team_info.team_name"
          },
          pace: "$pace",
          shooting: "$shooting",
          passing: "$passing",
          dribbling: "$dribbling",
          defending: "$defending",
          physic: "$physic",
          attacking_crossing: "$attacking_crossing",
          attacking_finishing: "$attacking_finishing",
          attacking_heading_accuracy: "$attacking_heading_accuracy",
          attacking_short_passing: "$attacking_short_passing",
          attacking_volleys: "$attacking_volleys",
          skill_dribbling: "$skill_dribbling",
          skill_curve: "$skill_curve",
          skill_fk_accuracy: "$skill_fk_accuracy",
          skill_long_passing: "$skill_long_passing",
          skill_ball_control: "$skill_ball_control",
          movement_acceleration: "$movement_acceleration",
          movement_sprint_speed: "$movement_sprint_speed",
          movement_agility: "$movement_agility",
          movement_reactions: "$movement_reactions",
          movement_balance: "$movement_balance",
          power_shot_power: "$power_shot_power",
          power_jumping: "$power_jumping",
          power_stamina: "$power_stamina",
          power_strength: "$power_strength",
          power_long_shots: "$power_long_shots",
          mentality_aggression: "$mentality_aggression",
          mentality_interceptions: "$mentality_interceptions",
          mentality_positioning: "$mentality_positioning",
          mentality_vision: "$mentality_vision",
          mentality_penalties: "$mentality_penalties",
          mentality_composure: "$mentality_composure",
          defending_marking_awareness: "$defending_marking_awareness",
          defending_standing_tackle: "$defending_standing_tackle",
          defending_sliding_tackle: "$defending_sliding_tackle",
          goalkeeping_diving: "$goalkeeping_diving",
          goalkeeping_handling: "$goalkeeping_handling",
          goalkeeping_kicking: "$goalkeeping_kicking",
          goalkeeping_positioning: "$goalkeeping_positioning",
          goalkeeping_reflexes: "$goalkeeping_reflexes"
        }
      }
    }
  },
  {
    $set: {
      _id: "$original_id"
    }
  },
  {
    $unset: "original_id"
  },
  {
    $merge: {
      into: "Players",
      whenMatched: "merge",
      whenNotMatched: "insert"
    }
  }
])

_____________________________________________________________________________

db.male_coaches.aggregate([
  {
    $lookup: {
      from: "male_teams",
      let: { coachId: "$coach_id" },
      pipeline: [
        {
          $match: {
            $expr: {
              $eq: ["$coach_id", "$$coachId"]
            }
          }
        }
      ],
      as: "team_info"
    }
  },
  {
    $unwind: {
      path: "$team_info",
      preserveNullAndEmptyArrays: true
    }
  },
  {
    $group: {
      _id: "$coach_id",
      original_id: { $first: "$_id" },
      coach_id: { $first: "$coach_id" },
      short_name: { $first: "$short_name" },
      long_name: { $first: "$long_name" },
      nationality_name: { $first: "$nationality_name" },
      gender: { $first: "male" },
      team: {
        $push: {
          team_mongo_id: "$team_info._id",
          team_id: "$team_info.team_id",
          team_name: "$team_info.team_name",
          fifa_version: "$team_info.fifa_version"
        }
      }
    }
  },
  {
    $set: {
      _id: "$original_id"
    }
  },
  {
    $unset: "original_id"
  },
  {
    $merge: {
      into: "Coaches",
      whenMatched: "merge",
      whenNotMatched: "insert"
    }
  }
])

_____________________________________________________________________________________________
db.male_teams.aggregate([
  {
    $lookup: {
      from: "male_coaches",
      localField: "coach_id",
      foreignField: "coach_id",
      as: "coach_info"
    }
  },
  {
    $unwind: {
      path: "$coach_info",
      preserveNullAndEmptyArrays: true
    }
  },
  {
    $group: {
      _id: "$team_id",
      original_id: { $first: "$_id" },
      team_id: { $first: "$team_id" },
      team_name: { $first: "$team_name" },
      gender: { $first: "male" },
      fifaStats: {
        $push: {
          coach: {
            coach_mongo_id: "$coach_info._id",
            coach_id: "$coach_id",
            coach_name: "$coach_info.long_name"
          },
          fifa_version: "$fifa_version",
          league_id: "$league_id",
          league_name: "$league_name",
          league_level: "$league_level",
          nationality_id: "$nationality_id",
          nationality_name: "$nationality_name",
          home_stadium: "$home_stadium",
          overall: "$overall",
          attack: "$attack",
          midfield: "$midfield",
          defence: "$defence",
          club_worth_eur: "$club_worth_eur",
          captain: "$captain",
          short_free_kick: "$short_free_kick",
          long_free_kick: "$long_free_kick",
          left_short_free_kick: "$left_short_free_kick",
          right_short_free_kick: "$right_short_free_kick",
          penalties: "$penalties",
          left_corner: "$left_corner",
          right_corner: "$right_corner",
          off_players_in_box: "$off_players_in_box",
          off_corners: "$off_corners",
          off_free_kicks: "$off_free_kicks"
        }
      }
    }
  },
  {
    $set: {
      _id: "$original_id"
    }
  },
  {
    $unset: "original_id"
  },
  {
    $merge: {
      into: "Teams",
      whenMatched: "merge",
      whenNotMatched: "insert"
    }
  }
])


________________________________________________________________________________________________________________________________________

db.articles.aggregate([
  {
    $group: {
      _id: "$_id",
      original_id: { $first: "$_id" },
      author: { $first: "$author" },
      title: { $first: "$title" },
      content: { $first: "$content" },
      publish_time: { $first: "$publish-time" } // Keep as string
    }
  },
  {
    $set: {
      _id: "$original_id"
    }
  },
  {
    $unset: "original_id"
  },
  {
    $merge: {
      into: "Articles",
      whenMatched: "merge",
      whenNotMatched: "insert"
    }
  }
])

_____________________________________________________________________________________________

//Function for hashing the password
const crypto = require('crypto');

function createSHA256Hash(inputString) {
    const hash = crypto.createHash('sha256');
    hash.update(inputString);
    return hash.digest('hex');
}

// Function to generate a random alphanumeric password
function generateRandomPassword(length = 12) {
    const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    let password = "";
    for (let i = 0; i < length; i++) {
        password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return createSHA256Hash(password);
}

//Function to generate random signup date
const startDate= new Date(2019,1,1);
const endDate= new Date(2022,12,31);
function generateRandomDate(startDate, endDate) {
  // Check if the input dates are valid
  if (!(startDate instanceof Date) || !(endDate instanceof Date)) {
    console.error("Invalid input: Both startDate and endDate must be Date objects.");
    return null;
  }

  // Check if startDate is before endDate
  if (startDate > endDate) {
    console.error("Invalid input: startDate must be before endDate.");
    return null;
  }

  // Calculate the time difference in milliseconds
  const startTime = startDate.getTime();
  const endTime = endDate.getTime();
  const timeDifference = endTime - startTime;

  // Generate a random time within the range
  const randomTime = Math.random() * timeDifference;

  // Create a new Date object with the random time
  const randomDate = new Date(startTime + randomTime);

  // Return a new Date object with only the year, month, and day.
  const year = randomDate.getFullYear();
  const month = randomDate.getMonth();
  const day = randomDate.getDate();
  return new Date(year, month, day).toLocaleDateString();
}

// Retrieve all distinct authors from the Articles collection
const articles = db.Articles.find();
const authorPatterns = [" / Author","By "," and ","GFFN | "];

// Iterate over each author to create a corresponding user
articles.forEach(article => {
    // Skip entries where the author field and publish time , null or empty
    //also some articles don't have an author correctly set
    //instead they have a long phrase
    //if the string is longer than 5 words

    let varAuthor=article.author;
    

    if (!varAuthor || varAuthor.length==0 || varAuthor.split(" ").length>5|| varAuthor=="Author not found") {
        return;
    }
    

    //removing if present some string patterns
    authorPatterns.forEach(pattern => {
    	if (varAuthor.includes(pattern)) {
		varAuthor=varAuthor.replace(pattern,"");
    	}
    });

    // Check if a user with the same username already exists
    if (db.Users.findOne({ username: varAuthor })) {
        return;
    }
    
    // Create the user document with username, random password, and role
    db.Users.insertOne({
        username: varAuthor,
        password: generateRandomPassword(),
	signup_date:generateRandomDate(startDate,endDate),
        roles: ["ROLE_USER"]
    });
});
______________________________________________________________________________________________________________________________

const validUserIds = db.Users.find({}, { _id: 1 }).toArray().map(user => user._id);

// Step 2: Delete all articles where the author is not in the list of valid users
const result = db.Articles.deleteMany({
  author: { $nin: validUserIds }
});

print(`${result.deletedCount} articles deleted.`);
______________________________________________________________________________________________________________________________


function parseSignupDate(str) {
  const [day, month, year] = str.split('/').map(Number);
  return new Date(year, month - 1, day); // month is 0-indexed
}

function generateRandomDateAfter(startDate) {
  
  const now = new Date();
  const start = parseSignupDate(startDate).getTime();
  const end = now.getTime();
  const randomTime = start + Math.random() * (end - start);
  
  const year = randomTime.getFullYear();
  const month = randomTime.getMonth();
  const day = randomTime.getDate();
  return new Date(year, month, day).toLocaleDateString();

}

// Loop through each user
db.Users.find({}).forEach(user => {

  const username = user.username;
  const signupDate = user.signup_date;

  if (!signupDate) {
    print('Skipping user ${username} (no subscription date)');
    return;
  }

  const articles = db.Articles.find({
	author: username,
	$or: [
		{ publish_time: null },
		{ publish_time: "Publish time not found" }
	]
  });

  articles.forEach(article => {   
	
	
	const randomDate = generateRandomDateAfter(signupDate);
    
    db.Articles.updateOne(
      { _id: article._id },
      { $set: { publish_time: randomDate } }
    );
   
  });

  print(`Updated articles for ${username}`);
});

___________________________________________________________________________________________-




